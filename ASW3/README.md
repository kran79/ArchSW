# Урок 6. Семинар: Принципы SOLID

_____________________________________________________________________________________________________

Задание:

Доработать упражнение, начатое на занятии
_____________________________________________________________________________________________________

# Принципы SOLID

## Программные структуры нижнего и среднего уровней

В разработке программного обеспечения важно понимать, как структурируются элементы системы на разных уровнях абстракции:

- **Нижний уровень**: включает в себя классы и модули. Класс служит шаблоном для создания объектов с определённым поведением и состоянием. Модуль — это набор классов и функций, сгруппированных логически.
- **Средний уровень**: представлен компонентами — более крупными единицами, которые объединяют классы, модули и конструкции языка по функциональному признаку.

> Модульность облегчает сопровождение кода, повышает читаемость и позволяет вносить изменения в одну часть системы без затрагивания остальных.

---

## Принципы SOLID

**SOLID** — это акроним из пяти фундаментальных принципов объектно-ориентированного проектирования, предложенных Робертом Мартином (дядя Боб). Эти принципы помогают писать более гибкий, масштабируемый и сопровождаемый код.

### Перечень принципов:

1. **SRP** — *Single Responsibility Principle* (Принцип единственной ответственности)
2. **OCP** — *Open/Closed Principle* (Принцип открытости/закрытости)
3. **LSP** — *Liskov Substitution Principle* (Принцип подстановки Барбары Лисков)
4. **ISP** — *Interface Segregation Principle* (Принцип разделения интерфейсов)
5. **DIP** — *Dependency Inversion Principle* (Принцип инверсии зависимостей)

---

## SRP — Принцип единственной ответственности

Каждый класс должен отвечать только за одну задачу и иметь единственную причину для изменения.

- Это означает, что изменения в одной функциональной области системы не должны затрагивать другие.
- Пример: если класс одновременно отвечает за отображение данных и их обработку, его следует разделить на два — один для представления, другой для логики.

> Деление ответственности способствует снижению связности и упрощает сопровождение кода.

---

## OCP — Принцип открытости/закрытости

Программные сущности (классы, модули, функции) должны быть **открыты для расширения**, но **закрыты для модификации**.

- Это позволяет добавлять новый функционал без необходимости изменения уже протестированного и надёжного кода.
- Пример: реализация базового класса и последующее добавление новых функций через наследование или внедрение зависимостей.

> Принцип помогает избежать ошибок при доработках и обеспечивает устойчивость системы.

---

## LSP — Принцип подстановки Лисков

Объекты подклассов должны быть взаимозаменяемы с объектами их суперклассов, не нарушая корректность программы.

- То есть, если метод ожидает объект суперкласса, он должен работать и с объектом любого его подкласса.
- Пример: если `Bird` имеет метод `fly()`, то подкласс `Penguin`, который не умеет летать, нарушает принцип LSP.

> Следование LSP гарантирует корректное поведение при использовании наследования.

---

## ISP — Принцип разделения интерфейсов

Клиенты не должны зависеть от интерфейсов, которые они не используют.

- Лучше создавать множество специализированных интерфейсов, чем один универсальный.
- Пример: интерфейсы `IDrawable`, `IMovable`, `IResizable` вместо одного общего `IShape` с множеством методов.

> Это снижает связанность и делает код гибче при расширении и модификации.

---

## DIP — Принцип инверсии зависимостей

Высокоуровневые модули не должны зависеть от низкоуровневых. Оба типа модулей должны зависеть от абстракций.

- Абстракции не должны зависеть от деталей. Напротив, детали должны зависеть от абстракций.
- Пример: использование интерфейсов или абстрактных классов, через которые взаимодействуют модули.

> DIP упрощает тестирование и замену компонентов без переписывания всего кода.
